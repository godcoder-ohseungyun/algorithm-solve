## DFS와 BFS는 선택의 문제일 뿐이다

DFS와 BFS는 둘다 경우의 수를 '완전 탐색'할 때, 사용한다

다만, 다음과 같은 특수한 환경에서 차이를 보인다
1. DFS는 최종 목적지에 방문한다 같은 상태 공간 트리의 '깊이'를 풀이하는 문제에서 탁월하다
2. BFS는 특정 위치에 최단으로 방문한다 같은 상태 공간 트리의 '넓이'를 풀이하는 문제에서 탁월하다

이런 경우를 제외하고 '완전 탐색'이 요구되는 상황에서는 자유롭게 사용하면 된다

하지만 나는 DFS를 선호한다, '재귀의 특성상' 코드가 명확하고 로직의 흐름을 파악하기 쉽기 때문이다

### 개인적으로 이 문제는 두 방식으로 모두 풀어보길 바란다

### 가지치기가 관건이다

완전 탐색은 풀이를 틀리기 보다 '시간 초과' 문제를 겪기 쉽다

때문에, 항상 '더 나은 가지치기'를 고민할 수 있어야한다

### 중간 과정을 기록하는 배열 ch를 활용해서 가지치기 향상

경주로 건설 문제는 BFS, DFS 모두 사용할 수 있다

그러나 처음 DFS를 사용했을 때, 시간 초과 문제를 겪었다

때문에 다음 코드의 두번째 줄 조건을 가지치기에 추가했다

이전에는 첫째 줄만 있어서 한번이라도 최종 도착지에 도착하고 난 후에 가지치기가 가능했으며,

최종 도착지까지 건설 비용을 중간 계산에서 뛰어넘기 힘들다는 한계가 있는데 이를 가지치기로 사용했다는 것이다

```
private void dfs(Point now, int total, int[][] board){
        if(total > min_fee) return; //방문 전 좌표라도 이미 건설 비용이 정답 후보 보다 크면 정지

        if(ch[now.y][now.x] < total) return; //이전 방문 기록이 현재 건설 비용보다 저렴하면 정지
        ...
```

solve : 두번째 줄을 추가하면, '완전 탐색 과정'을 ch에 기록하고 있다가 이후 다른 경로로 해당 좌표에 접근했을 때 가지치기가 가능하다는 장점이 있다

때문에, 굳이 한번이라도 최종 점에 도달할 필요가 없으며, 중간 과정에서도 충분히 가지치기가 가능하다

### 핵심은 방문 기록 배열 ch 이다
이제까지는 방문 기록 배열을 0,1로 표시하는 단순 표기용으로 사용했다면

경우에 따라 '비용을 넣는다'등 다양한 기준으로 활용할 수 있다는 것을 인지해야한다

### 방향 연산시 인덱스는 방향임을 인지해야 한다
Point 객체는 y,x,d(방향)을 매개변수로 가진다

방향 연산의 인덱스를 방향으로 여긴다면, 이전 기록으로 도출할 필요없이, 이 d와 비교하여 간단하게 같은 방향인지 파악할 수 있다

-1은 무방향을 의미한다
```
for(int d=0;d<4;d++){ 
     int ny = now.y + dy[d];
     int nx = now.x + dx[d];
     
     if(now.d == -1 || now.d == d){ ... }//출발지거나 직선인 경우
}
```

